{"version":3,"names":["_types","require","_lval","_identifier","_location","_scopeflags","_util","_productionParameter","_expressionScope","_parseError","_pipelineOperatorErrors","_comments","_node","ExpressionParser","LValParser","checkProto","prop","isRecord","protoRef","refExpressionErrors","type","isObjectMethod","computed","shorthand","key","name","value","raise","Errors","RecordNoProto","at","used","doubleProtoLoc","loc","start","DuplicateProto","shouldExitDescending","expr","potentialArrowAt","getExpression","enterInitialScopes","nextToken","parseExpression","match","unexpected","finalizeRemainingComments","comments","state","errors","options","tokens","disallowIn","disallowInAnd","parseExpressionBase","allowInAnd","startLoc","parseMaybeAssign","node","startNodeAt","expressions","eat","push","toReferencedList","finishNode","parseMaybeAssignDisallowIn","afterLeftParse","parseMaybeAssignAllowIn","setOptionalParametersError","resultError","_resultError$loc","optionalParametersLoc","isContextual","prodParam","hasYield","left","parseYield","call","ownExpressionErrors","ExpressionErrors","tokenIsIdentifier","parseMaybeConditional","tokenIsAssignment","operator","toAssignable","startIndex","index","shorthandAssignLoc","privateKeyLoc","checkDestructuringPrivate","next","right","checkLVal","in","checkExpressionErrors","parseExprOps","parseConditional","test","consequent","expect","alternate","parseMaybeUnaryOrPrivate","parsePrivateName","parseMaybeUnary","parseExprOp","leftStartLoc","minPrec","isPrivateName","getPrivateNameSV","tokenOperatorPrecedence","hasIn","PrivateInExpectedIn","identifierName","classScope","usePrivateName","op","tokenIsOperator","prec","expectPlugin","inFSharpPipelineDirectBody","checkPipelineAtInfixOperator","logical","coalesce","hasPlugin","proposal","hasAwait","UnexpectedAwaitAfterPipelineBody","parseExprOpRightExpr","finishedNode","nextOp","MixingCoalesceWithLogical","getPluginOption","withTopicBindingContext","parseHackPipeBody","PipeBodyIsTighter","parseSmartPipelineBodyInStyle","parseExprOpBaseRightExpr","withSoloAwaitPermittingContext","parseFSharpPipelineBody","tokenIsRightAssociative","_body$extra","body","requiredParentheses","UnparenthesizedPipeBodyDescriptions","has","extra","parenthesized","PipeUnparenthesizedBody","topicReferenceWasUsedInCurrentContext","PipeTopicUnused","checkExponentialAfterUnary","UnexpectedTokenUnaryExponentiation","argument","sawUnary","isAwait","isAwaitAllowed","parseAwait","update","startNode","tokenIsPrefix","prefix","isDelete","strict","arg","StrictDelete","hasPropertyAsPrivateName","DeletePrivateField","parseUpdate","startsExpr","tokenCanStartExpression","isAmbiguousAwait","raiseOverwrite","AwaitNotInAsyncContext","updateExpressionNode","parseExprSubscripts","tokenIsPostfix","canInsertSemicolon","parseExprAtom","parseSubscripts","base","noCalls","optionalChainMember","maybeAsyncArrow","atPossibleAsyncArrow","stop","parseSubscript","parseBind","tokenIsTemplate","parseTaggedTemplateExpression","optional","OptionalChainingNoNew","lookaheadCharCode","parseCoverCallAndAsyncArrowHead","parseMember","object","property","SuperPrivateField","parseIdentifier","callee","parseNoCallExpr","oldMaybeInArrowParameters","maybeInArrowParameters","expressionScope","enter","newAsyncArrowScope","arguments","parseCallExpressionArguments","finishCallExpression","shouldParseAsyncArrow","validateAsPattern","exit","parseAsyncArrowFromCallExpression","toReferencedArguments","isParenthesizedExpr","toReferencedListDeep","tag","quasi","parseTemplate","OptionalChainingNoTemplate","lastTokEndLoc","end","expectImportAttributesPlugin","length","ImportCallArity","maxArgumentCount","ImportCallSpreadArgument","close","dynamicImport","allowPlaceholder","nodeForExtra","elts","first","oldInFSharpPipelineDirectBody","ImportCallArgumentTrailingComma","lastTokStartLoc","addTrailingCommaExtraToNode","parseExprListItem","_call$extra","resetPreviousNodeTrailingComments","parseArrowExpression","trailingCommaLoc","innerComments","setInnerComments","trailingComments","decorators","parseSuper","parseImportMetaProperty","UnsupportedImport","parseDo","readRegexp","parseRegExpLiteral","parseNumericLiteral","parseBigIntLiteral","parseDecimalLiteral","parseStringLiteral","parseNullLiteral","parseBooleanLiteral","canBeArrow","parseParenAndDistinguishExpression","parseArrayLike","parseObjectLike","parseFunctionOrFunctionSent","parseDecorators","parseClass","maybeTakeDecorators","parseNewOrNewTarget","UnsupportedBind","parseTopicReferenceThenEqualsSign","parseTopicReference","pipeProposal","lookaheadCh","input","codePointAt","nextTokenStart","isIdentifierStart","expectOnePlugin","lookaheadInLineCharCode","parseModuleExpression","containsEsc","id","parseAsyncFunctionExpression","startNodeAtNode","parseAsyncArrowUnaryFunction","topicTokenType","topicTokenValue","pos","endLoc","createPositionWithColumnOffset","tokenType","finishTopicReference","testTopicReferenceConfiguration","nodeType","topicReferenceIsAllowedInCurrentContext","PrimaryTopicNotAllowed","PipeTopicUnbound","registerTopicReference","PipeTopicUnconfiguredToken","token","tokenLabelName","topicToken","PipeTopicRequiresHackPipes","functionFlags","params","hasPrecedingLineBreak","LineTerminatorBeforeArrow","curPosition","isAsync","async","oldLabels","labels","PARAM_AWAIT","parseBlock","scope","allowDirectSuper","allowSuperOutsideMethod","SuperNotAllowed","allowSuper","UnexpectedSuper","UnsupportedSuper","createIdentifier","meta","parseMetaProperty","parseFunction","propertyName","UnsupportedMetaProperty","target","onlyValidPropertyName","inModule","ImportMetaOutsideModule","sawUnambiguousESM","parseLiteralAtNode","addExtra","slice","parseLiteral","pattern","flags","val","newArrowHeadScope","innerStartLoc","exprList","spreadStartLoc","optionalCommaStartLoc","spreadNodeStartLoc","parseParenItem","parseRestBinding","checkCommaAfterRest","innerEndLoc","arrowNode","shouldParseArrow","parseArrow","resetEndLocation","wrapParenthesis","expression","createParenthesizedExpressions","takeSurroundingComments","parenExpression","metaProp","inNonArrowFunction","inClass","allowNewTargetOutsideFunction","UnexpectedNewTarget","parseNew","parseNewCallee","args","parseExprList","ImportCallNotNewExpression","parseTemplateElement","isTagged","elemStart","elem","InvalidEscapeSequenceTemplate","firstInvalidTemplateEscapePos","isTail","endOffset","elemEnd","raw","replace","cooked","tail","curElt","quasis","parseTemplateSubstitution","readTemplateContinuation","isPattern","propHash","Object","create","properties","parseBindingProperty","parsePropertyDefinition","isObjectProperty","InvalidRecordProperty","lastTokStart","maybeAsyncOrAccessorProp","isLiteralPropertyName","UnsupportedPropertyDecorator","parseDecorator","isAccessor","parseSpread","method","isGenerator","parsePropertyNamePrefixOperator","parsePropertyName","keyName","kind","AccessorIsGenerator","parseObjPropValue","getGetterSetterExpectedParamCount","getObjectOrClassMethodParams","checkGetterSetterParams","_params","paramCount","BadGetterArity","BadSetterArity","BadSetterRestParameter","parseObjectMethod","finishedProp","parseMethod","parseObjectProperty","parseMaybeDefault","checkReservedWord","cloneIdentifier","InvalidCoverInitializedName","tokenIsKeywordOrIdentifier","UnexpectedPrivateField","initFunction","generator","isConstructor","inClassScope","SCOPE_FUNCTION","SCOPE_SUPER","SCOPE_CLASS","SCOPE_DIRECT_SUPER","parseFunctionParams","parseFunctionBodyAndFinish","canBePattern","isTuple","elements","SCOPE_ARROW","PARAM_IN","setArrowFunctionParameters","parseFunctionBody","toAssignableList","isMethod","allowExpression","isExpression","newExpressionScope","checkParams","oldStrict","currentFlags","PARAM_RETURN","hasStrictModeDirective","nonSimple","isSimpleParamList","IllegalLanguageModeDirective","strictModeChanged","checkIdentifier","BIND_OUTSIDE","isSimpleParameter","i","len","allowDuplicates","isArrowFunction","checkClashes","Set","formalParameters","param","binding","BIND_VAR","allowEmpty","elt","UnexpectedToken","UnexpectedArgumentPlaceholder","liberal","parseIdentifierName","tokenIsKeyword","tokenKeywordOrIdentifierIsKeyword","replaceToken","word","checkKeywords","isBinding","canBeReservedWord","isKeyword","UnexpectedKeyword","keyword","reservedTest","isReservedWord","isStrictBindReservedWord","isStrictReservedWord","UnexpectedReservedWord","reservedWord","YieldBindingIdentifier","AwaitBindingIdentifier","inStaticBlock","AwaitBindingIdentifierInStaticBlock","recordAsyncArrowParametersError","inClassAndNotInNonArrowFunction","ArgumentsInClass","allowAwaitOutsideFunction","inFunction","recordParameterInitializerError","AwaitExpressionFormalParameter","ObsoleteAwaitStar","ambiguousScriptDifferentAst","soloAwait","YieldInParameter","delegating","delegate","PipelineHeadSequenceExpression","childExpr","isSimpleReference","bodyNode","checkSmartPipeTopicBodyEarlyErrors","PipelineBodyNoArrow","PipelineTopicUnused","callback","outerContextTopicState","topicContext","maxNumOfResolvableTopics","maxTopicIndex","withSmartMixTopicForbiddingContext","outerContextSoloAwaitState","prodParamToSet","prodParamToClear","ret","program","revertScopes","initializeScopes","parseProgram","exports","default"],"sources":["../../src/parser/expression.ts"],"sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  tokenCanStartExpression,\n  tokenIsAssignment,\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsOperator,\n  tokenIsPostfix,\n  tokenIsPrefix,\n  tokenIsRightAssociative,\n  tokenIsTemplate,\n  tokenKeywordOrIdentifierIsKeyword,\n  tokenLabelName,\n  tokenOperatorPrecedence,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types\";\nimport type * as N from \"../types\";\nimport LValParser from \"./lval\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n  canBeReservedWord,\n} from \"../util/identifier\";\nimport {\n  type Position,\n  createPositionWithColumnOffset,\n} from \"../util/location\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_OUTSIDE,\n  BIND_VAR,\n  SCOPE_ARROW,\n  SCOPE_CLASS,\n  SCOPE_DIRECT_SUPER,\n  SCOPE_FUNCTION,\n  SCOPE_SUPER,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport {\n  PARAM_AWAIT,\n  PARAM_IN,\n  PARAM_RETURN,\n  functionFlags,\n} from \"../util/production-parameter\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope\";\nimport { Errors, type ParseError } from \"../parse-error\";\nimport { UnparenthesizedPipeBodyDescriptions } from \"../parse-error/pipeline-operator-errors\";\nimport { setInnerComments } from \"./comments\";\nimport { cloneIdentifier, type Undone } from \"./node\";\nimport type Parser from \".\";\n\nimport type { SourceType } from \"../options\";\n\nexport default abstract class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  abstract parseBlock(\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement;\n  abstract parseClass(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ): N.Class;\n  abstract parseDecorators(allowExport?: boolean): void;\n  abstract parseFunction<T extends N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ): T;\n  abstract parseFunctionParams(node: N.Function, isConstructor?: boolean): void;\n  abstract parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: N.Directive[] | null | undefined,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void;\n  abstract parseProgram(\n    program: N.Program,\n    end: TokenType,\n    sourceType?: SourceType,\n  ): N.Program;\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: boolean | undefined | null,\n    protoRef: {\n      used: boolean;\n    },\n    refExpressionErrors?: ExpressionErrors | null,\n  ): void {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      // @ts-expect-error prop must be an ObjectProperty\n      prop.shorthand\n    ) {\n      return;\n    }\n\n    const key = prop.key;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, { at: key });\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, { at: key });\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {\n    return (\n      expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(this: Parser): N.Expression & N.ParserOutput {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    // Unlike parseTopLevel, we need to drain remaining commentStacks\n    // because the top level node is _not_ Program.\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    // @ts-expect-error fixme: refine types\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    this: Parser,\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // This method is only used by\n  // the typescript and flow plugins.\n  setOptionalParametersError(\n    refExpressionErrors: ExpressionErrors,\n    resultError?: ParseError<any>,\n  ) {\n    refExpressionErrors.optionalParametersLoc =\n      resultError?.loc ?? this.state.startLoc;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    afterLeftParse?: Function,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(tt._yield)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const { type } = this.state;\n\n    if (type === tt.parenL || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt<N.AssignmentExpression>(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        this.toAssignable(left, /* isLHS */ true);\n        node.left = left;\n\n        const startIndex = startLoc.index;\n        if (\n          refExpressionErrors.doubleProtoLoc != null &&\n          refExpressionErrors.doubleProtoLoc.index >= startIndex\n        ) {\n          refExpressionErrors.doubleProtoLoc = null; // reset because double __proto__ is valid in assignment expression\n        }\n        if (\n          refExpressionErrors.shorthandAssignLoc != null &&\n          refExpressionErrors.shorthandAssignLoc.index >= startIndex\n        ) {\n          refExpressionErrors.shorthandAssignLoc = null; // reset because shorthand default was used correctly\n        }\n        if (\n          refExpressionErrors.privateKeyLoc != null &&\n          refExpressionErrors.privateKeyLoc.index >= startIndex\n        ) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null; // reset because `({ #x: x })` is an assignable pattern\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, {\n        in: this.finishNode(node, \"AssignmentExpression\"),\n      });\n      // @ts-expect-error todo(flow->ts) improve node types\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(\n    this: Parser,\n    expr: N.Expression,\n    startLoc: Position,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression | N.PrivateName {\n    return this.match(tt.privateName)\n      ? this.parsePrivateName()\n      : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(\n    this: Parser,\n    refExpressionErrors: ExpressionErrors,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    this: Parser,\n    left: N.Expression | N.PrivateName,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    if (this.isPrivateName(left)) {\n      // https://tc39.es/ecma262/#prod-RelationalExpression\n      // RelationalExpression [In, Yield, Await]\n      //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n\n      const value = this.getPrivateNameSV(left);\n\n      if (\n        minPrec >= tokenOperatorPrecedence(tt._in) ||\n        !this.prodParam.hasIn ||\n        !this.match(tt._in)\n      ) {\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: left,\n          identifierName: value,\n        });\n      }\n\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(tt._in))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt<N.LogicalExpression | N.BinaryExpression>(\n          leftStartLoc,\n        );\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = tokenOperatorPrecedence(tt.logicalAND);\n        }\n\n        this.next();\n\n        if (\n          op === tt.pipeline &&\n          this.hasPlugin([\"pipelineOperator\", { proposal: \"minimal\" }])\n        ) {\n          if (this.state.type === tt._await && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, {\n              at: this.state.startLoc,\n            });\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(tt._yield)) {\n                throw this.raise(Errors.PipeBodyIsTighter, {\n                  at: this.state.startLoc,\n                });\n              }\n              return this.parseSmartPipelineBodyInStyle(\n                this.parseExprOpBaseRightExpr(op, prec),\n                startLoc,\n              );\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      // Falls through.\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(\n    this: Parser,\n    op: TokenType,\n    prec: number,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startLoc,\n      tokenIsRightAssociative(op) ? prec - 1 : prec,\n    );\n  }\n\n  parseHackPipeBody(this: Parser): N.Expression {\n    const { startLoc } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(\n      // @ts-expect-error TS2345: Argument of type 'string' is not assignable to parameter of type '\"ArrowFunctionExpression\" | \"YieldExpression\" | \"AssignmentExpression\" | \"ConditionalExpression\"'.\n      body.type,\n    );\n\n    // TODO: Check how to handle type casts in Flow and TS once they are supported\n    if (requiredParentheses && !body.extra?.parenthesized) {\n      this.raise(Errors.PipeUnparenthesizedBody, {\n        at: startLoc,\n        // @ts-expect-error TS2322: Type 'string' is not assignable to type '\"AssignmentExpression\" | \"ArrowFunctionExpression\" | \"ConditionalExpression\" | \"YieldExpression\"'.\n        type: body.type,\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(Errors.PipeTopicUnused, { at: startLoc });\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(\n    node: N.AwaitExpression | Undone<N.UnaryExpression>,\n  ) {\n    if (this.match(tt.exponent)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, {\n        at: node.argument,\n      });\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(tt._await);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode<N.UnaryExpression | N.UpdateExpression>();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, { at: node });\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, { at: node });\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node as Undone<N.UnaryExpression>);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(\n      // @ts-expect-error using \"Undone\" node as \"done\"\n      node,\n      update,\n      refExpressionErrors,\n    );\n\n    if (isAwait) {\n      const { type } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? tokenCanStartExpression(type)\n        : tokenCanStartExpression(type) && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, { at: startLoc });\n        return this.parseAwait(startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    this: Parser,\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    if (update) {\n      // @ts-expect-error Type 'Node' is missing the following properties from type 'Undone<UpdateExpression>': prefix, operator, argument\n      const updateExpressionNode = node as Undone<N.UpdateExpression>;\n      this.checkLVal(updateExpressionNode.argument, {\n        in: this.finishNode(updateExpressionNode, \"UpdateExpression\"),\n      });\n      return node;\n    }\n\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt<N.UpdateExpression>(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, {\n        in: (expr = this.finishNode(node, \"UpdateExpression\")),\n      });\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startLoc);\n  }\n\n  parseSubscripts(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls?: boolean | null,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const { type } = this.state;\n    if (!noCalls && type === tt.doubleColon) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n\n    let optional = false;\n\n    if (type === tt.questionDot) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, {\n          at: this.state.startLoc,\n        });\n        if (this.lookaheadCharCode() === charCodes.leftParenthesis) {\n          // stop at `?.` when parsing `new a?.()`\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startLoc,\n        state,\n        optional,\n      );\n    } else {\n      const computed = this.eat(tt.bracketL);\n      if (computed || optional || this.eat(tt.dot)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    computed: boolean,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt<\n      N.OptionalMemberExpression | N.MemberExpression\n    >(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(tt.bracketR);\n    } else if (this.match(tt.privateName)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, { at: startLoc });\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n\n    if (state.optionalChainMember) {\n      (node as N.OptionalMemberExpression).optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    noCalls: boolean | undefined | null,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next(); // eat '::'\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors: ExpressionErrors | null = null;\n\n    this.state.maybeInArrowParameters = true;\n    this.next(); // eat `(`\n\n    const node = this.startNodeAt<N.CallExpression | N.OptionalCallExpression>(\n      startLoc,\n    );\n    node.callee = base;\n    const { maybeAsyncArrow, optionalChainMember } = state;\n\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (optionalChainMember) {\n      // @ts-expect-error when optionalChainMember is true, node must be an optional call\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        base.type === \"Import\",\n        base.type !== \"Super\",\n        // @ts-expect-error todo(flow->ts)\n        node,\n        refExpressionErrors,\n      );\n    }\n    let finishedNode:\n      | N.CallExpression\n      | N.OptionalCallExpression\n      | N.ArrowFunctionExpression = this.finishCallExpression(\n      node,\n      optionalChainMember,\n    );\n\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      /*:: invariant(refExpressionErrors != null) */\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt<N.ArrowFunctionExpression>(startLoc),\n        finishedNode as N.CallExpression,\n      );\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return finishedNode;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    this: Parser,\n    base: N.Expression,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node = this.startNodeAt<N.TaggedTemplateExpression>(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, { at: startLoc });\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEndLoc.index === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      base.start === this.state.potentialArrowAt\n    );\n  }\n\n  expectImportAttributesPlugin() {\n    if (!this.hasPlugin(\"importAssertions\")) {\n      this.expectPlugin(\"importAttributes\");\n    }\n  }\n\n  finishCallExpression<T extends N.CallExpression | N.OptionalCallExpression>(\n    node: Undone<T>,\n    optional: boolean,\n  ): T {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (process.env.BABEL_8_BREAKING) {\n          this.expectImportAttributesPlugin();\n        } else {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectImportAttributesPlugin();\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, {\n          at: node,\n          maxArgumentCount:\n            this.hasPlugin(\"importAttributes\") ||\n            this.hasPlugin(\"importAssertions\") ||\n            this.hasPlugin(\"moduleAttributes\")\n              ? 2\n              : 1,\n        });\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, { at: arg });\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    this: Parser,\n    close: TokenType,\n    dynamicImport?: boolean,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: N.Node | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): Array<N.Expression | undefined | null> {\n    const elts: N.Expression[] = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (\n            dynamicImport &&\n            !this.hasPlugin(\"importAttributes\") &&\n            !this.hasPlugin(\"importAssertions\") &&\n            !this.hasPlugin(\"moduleAttributes\")\n          ) {\n            this.raise(Errors.ImportCallArgumentTrailingComma, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingCommaLoc,\n    );\n    // mark inner comments of `async()` as inner comments of `async () =>`\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    // mark trailing comments of `async` to be inner comments\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node as N.ArrowFunctionExpression;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(this: Parser): N.Expression {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.Expression {\n    let node;\n    let decorators: N.Decorator[] | null = null;\n\n    const { type } = this.state;\n    switch (type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode<N.MetaProperty | N.Import>();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node as Undone<N.MetaProperty>);\n        }\n\n        if (!this.match(tt.parenL)) {\n          this.raise(Errors.UnsupportedImport, {\n            at: this.state.lastTokStartLoc,\n          });\n        }\n        return this.finishNode(node, \"Import\");\n      case tt._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt._do: {\n        return this.parseDo(this.startNode(), false);\n      }\n\n      case tt.slash:\n      case tt.slashAssign: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n\n      case tt.num:\n        return this.parseNumericLiteral(this.state.value);\n\n      case tt.bigint:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case tt.decimal:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case tt.string:\n        return this.parseStringLiteral(this.state.value);\n\n      case tt._null:\n        return this.parseNullLiteral();\n\n      case tt._true:\n        return this.parseBooleanLiteral(true);\n      case tt._false:\n        return this.parseBooleanLiteral(false);\n\n      case tt.parenL: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        decorators = this.parseDecorators();\n      // fall through\n      case tt._class:\n        return this.parseClass(\n          this.maybeTakeDecorators(decorators, this.startNode()),\n          false,\n        );\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.templateNonTail:\n      case tt.templateTail:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(Errors.UnsupportedBind, { at: callee });\n        }\n      }\n\n      case tt.privateName: {\n        // Standalone private names are only allowed in \"#x in obj\"\n        // expressions, and they are directly handled by callers of\n        // parseExprOp. If we reach this, the input is always invalid.\n        // We can throw a better error message and recover, rather than\n        // just throwing \"Unexpected token\" (which is the default\n        // behavior of this big switch statement).\n        this.raise(Errors.PrivateInExpectedIn, {\n          at: this.state.startLoc,\n          identifierName: this.state.value,\n        });\n        return this.parsePrivateName();\n      }\n\n      case tt.moduloAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.modulo, \"%\");\n      }\n\n      case tt.xorAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, \"^\");\n      }\n\n      case tt.doubleCaret:\n      case tt.doubleAt: {\n        return this.parseTopicReference(\"hack\");\n      }\n\n      case tt.bitwiseXOR:\n      case tt.modulo:\n      case tt.hash: {\n        const pipeProposal = this.getPluginOption(\n          \"pipelineOperator\",\n          \"proposal\",\n        );\n\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        }\n        this.unexpected();\n        break;\n      }\n\n      case tt.lt: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (\n          isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n          lookaheadCh === charCodes.greaterThan // Fragment <>\n        ) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n        } else {\n          this.unexpected();\n        }\n        break;\n      }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (\n            this.isContextual(tt._module) &&\n            this.lookaheadInLineCharCode() === charCodes.leftCurlyBrace\n          ) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (\n            !containsEsc &&\n            id.name === \"async\" &&\n            !this.canInsertSemicolon()\n          ) {\n            const { type } = this.state;\n            if (type === tt._function) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(\n                this.startNodeAtNode(id),\n              );\n            } else if (tokenIsIdentifier(type)) {\n              // If the next token begins with \"=\", commit to parsing an async\n              // arrow function. (Peeking ahead for \"=\" lets us avoid a more\n              // expensive full-token lookahead on this common path.)\n              if (this.lookaheadCharCode() === charCodes.equalsTo) {\n                // although `id` is not used in async arrow unary function,\n                // we don't need to reset `async`'s trailing comments because\n                // it will be attached to the upcoming async arrow binding identifier\n                return this.parseAsyncArrowUnaryFunction(\n                  this.startNodeAtNode(id),\n                );\n              } else {\n                // Otherwise, treat \"async\" as an identifier and let calling code\n                // deal with the current tt.name token.\n                return id;\n              }\n            } else if (type === tt._do) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (\n            canBeArrow &&\n            this.match(tt.arrow) &&\n            !this.canInsertSemicolon()\n          ) {\n            this.next();\n            return this.parseArrowExpression(\n              this.startNodeAtNode(id),\n              [id],\n              false,\n            );\n          }\n\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n\n  // This helper method should only be called\n  // when the parser has reached a potential Hack pipe topic token\n  // that is followed by an equals sign.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  // If we find ^= or %= in an expression position\n  // (i.e., the tt.moduloAssign or tt.xorAssign token types), and if the\n  // Hack-pipes proposal is active with ^ or % as its topicToken, then the ^ or\n  // % could be the topic token (e.g., in x |> ^==y or x |> ^===y), and so we\n  // reparse the current token as ^ or %.\n  // Otherwise, this throws an unexpected-token error.\n  parseTopicReferenceThenEqualsSign(\n    topicTokenType: TokenType,\n    topicTokenValue: string,\n  ): N.Expression {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      // Set the most-recent token to be a topic token\n      // given by the tokenType and tokenValue.\n      // Now the next readToken() call (in parseTopicReference)\n      // will consume that “topic token”.\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      // Rewind the tokenizer to the end of the “topic token”, so that the\n      // following token starts at the equals sign after that topic token.\n      this.state.pos--;\n      this.state.end--;\n      // This is safe to do since the preceding character was either ^ or %, and\n      // thus not a newline.\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      // Now actually consume the topic token.\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // This helper method should only be called\n  // when the proposal-pipeline-operator plugin is active,\n  // and when the parser has reached a potential Hack pipe topic token.\n  // Although a pipe-operator proposal is assumed to be active,\n  // its configuration might not match the current token’s type.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  parseTopicReference(pipeProposal: string): N.Expression {\n    const node = this.startNode<N.TopicReference>();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n\n    // Consume the current token.\n    this.next();\n\n    // If the pipe-operator plugin’s configuration matches the current token’s type,\n    // then this will return `node`, will have been finished as a topic reference.\n    // Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n\n  // This helper method attempts to finish the given `node`\n  // into a topic-reference node for the given `pipeProposal`.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  //\n  // The method assumes that any topic token was consumed before it was called.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // and if the given `tokenType` matches the plugin’s configuration,\n  // then this method will return the finished `node`.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // but if the given `tokenType` does not match the plugin’s configuration,\n  // then this method will throw a `PipeTopicUnconfiguredToken` error.\n  finishTopicReference(\n    node: Undone<N.Node>,\n    startLoc: Position,\n    pipeProposal: string,\n    tokenType: TokenType,\n  ): N.Expression {\n    if (\n      this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)\n    ) {\n      // The token matches the plugin’s configuration.\n      // The token is therefore a topic reference.\n\n      // Determine the node type for the topic reference\n      // that is appropriate for the active pipe-operator proposal.\n      const nodeType =\n        pipeProposal === \"smart\"\n          ? \"PipelinePrimaryTopicReference\"\n          : // The proposal must otherwise be \"hack\",\n            // as enforced by testTopicReferenceConfiguration.\n            \"TopicReference\";\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(\n          // The topic reference is not allowed in the current context:\n          // it is outside of a pipe body.\n          // Raise recoverable errors.\n          pipeProposal === \"smart\"\n            ? Errors.PrimaryTopicNotAllowed\n            : // In this case, `pipeProposal === \"hack\"` is true.\n              Errors.PipeTopicUnbound,\n          { at: startLoc },\n        );\n      }\n\n      // Register the topic reference so that its pipe body knows\n      // that its topic was used at least once.\n      this.registerTopicReference();\n\n      return this.finishNode(node, nodeType);\n    } else {\n      // The token does not match the plugin’s configuration.\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, {\n        at: startLoc,\n        token: tokenLabelName(tokenType),\n      });\n    }\n  }\n\n  // This helper method tests whether the given token type\n  // matches the pipelineOperator parser plugin’s configuration.\n  // If the active pipe proposal is Hack style,\n  // and if the given token is the same as the plugin configuration’s `topicToken`,\n  // then this is a valid topic reference.\n  // If the active pipe proposal is smart mix,\n  // then the topic token must always be `#`.\n  // If the active pipe proposal is neither (e.g., \"minimal\" or \"fsharp\"),\n  // then an error is thrown.\n  testTopicReferenceConfiguration(\n    pipeProposal: string,\n    startLoc: Position,\n    tokenType: TokenType,\n  ): boolean {\n    switch (pipeProposal) {\n      case \"hack\": {\n        return this.hasPlugin([\n          \"pipelineOperator\",\n          {\n            // @ts-expect-error token must have a label\n            topicToken: tokenLabelName(tokenType),\n          },\n        ]);\n      }\n      case \"smart\":\n        return tokenType === tt.hash;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, { at: startLoc });\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(\n    this: Parser,\n    node: Undone<N.ArrowFunctionExpression>,\n  ): N.ArrowFunctionExpression {\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, {\n        at: this.state.curPosition(),\n      });\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    return this.parseArrowExpression(node, params, true);\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  // https://github.com/tc39/proposal-async-do-expressions\n  parseDo(\n    this: Parser,\n    node: Undone<N.DoExpression>,\n    isAsync: boolean,\n  ): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      // AsyncDoExpression :\n      // async [no LineTerminator here] do Block[~Yield, +Await, ~Return]\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode<N.Super>();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.SuperNotAllowed, { at: node });\n    } else if (\n      !this.scope.allowSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(Errors.UnexpectedSuper, { at: node });\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(Errors.UnsupportedSuper, { at: node });\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName(): N.PrivateName {\n    const node = this.startNode<N.PrivateName>();\n    const id = this.startNodeAt<N.Identifier>(\n      // The position is hardcoded because we merge `#` and name into a single\n      // tt.privateName token\n      createPositionWithColumnOffset(this.state.startLoc, 1),\n    );\n    const name = this.state.value;\n    this.next(); // eat #name;\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent(\n    this: Parser,\n  ): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode<N.FunctionExpression | N.MetaProperty>();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.match(tt._sent)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n      return this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"sent\",\n      );\n    }\n    return this.parseFunction(node as Undone<N.FunctionExpression>);\n  }\n\n  parseMetaProperty(\n    node: Undone<N.MetaProperty>,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, {\n        at: node.property,\n        target: meta.name,\n        onlyValidPropertyName: propertyName,\n      });\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(node: Undone<N.MetaProperty>): N.MetaProperty {\n    const id = this.createIdentifier(\n      this.startNodeAtNode<N.Identifier>(node),\n      \"import\",\n    );\n    this.next(); // eat `.`\n\n    if (this.isContextual(tt._meta)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, { at: id });\n      }\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteralAtNode<T extends N.Node>(\n    value: any,\n    type: T[\"type\"],\n    node: any,\n  ): T {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode<T>(node, type);\n  }\n\n  parseLiteral<T extends N.Node>(value: any, type: T[\"type\"]): T {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value: any) {\n    return this.parseLiteral<N.StringLiteral>(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value: any) {\n    return this.parseLiteral<N.NumericLiteral>(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value: any) {\n    return this.parseLiteral<N.BigIntLiteral>(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value: any) {\n    return this.parseLiteral<N.DecimalLiteral>(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value: {\n    value: any;\n    pattern: string;\n    flags: N.RegExpLiteral[\"flags\"];\n  }) {\n    const node = this.parseLiteral<N.RegExpLiteral>(\n      value.value,\n      \"RegExpLiteral\",\n    );\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value: boolean) {\n    const node = this.startNode<N.BooleanLiteral>();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode<N.NullLiteral>();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(\n    this: Parser,\n    canBeArrow: boolean,\n  ): N.Expression {\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartLoc = this.state.startLoc;\n    const exprList: N.Expression[] = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(\n          tt.comma,\n          refExpressionErrors.optionalParametersLoc === null\n            ? null\n            : refExpressionErrors.optionalParametersLoc,\n        );\n        if (this.match(tt.parenR)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(\n          this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc),\n        );\n\n        if (!this.checkCommaAfterRest(charCodes.rightParenthesis)) {\n          break;\n        }\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n          ),\n        );\n      }\n    }\n\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt<N.ArrowFunctionExpression>(startLoc);\n    if (\n      canBeArrow &&\n      this.shouldParseArrow(exprList) &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      // @ts-expect-error todo(flow->ts) improve node types\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt<N.SequenceExpression>(innerStartLoc);\n      val.expressions = exprList;\n      // finish node at current location so it can pick up comments after `)`\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    return this.wrapParenthesis(\n      startLoc,\n      // @ts-expect-error todo(flow->ts)\n      val,\n    );\n  }\n\n  wrapParenthesis(startLoc: Position, expression: N.Expression): N.Expression {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n\n      this.takeSurroundingComments(\n        expression,\n        startLoc.index,\n        this.state.lastTokEndLoc.index,\n      );\n\n      return expression;\n    }\n\n    const parenExpression =\n      this.startNodeAt<N.ParenthesizedExpression>(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- `params` is used in typescript plugin\n  shouldParseArrow(params: Array<N.Node>): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(\n    node: Undone<N.ArrowFunctionExpression>,\n  ): Undone<N.ArrowFunctionExpression> | undefined {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(\n    node: N.Expression,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLoc: Position,\n  ): N.Expression {\n    return node;\n  }\n\n  parseNewOrNewTarget(this: Parser): N.NewExpression | N.MetaProperty {\n    const node = this.startNode<N.NewExpression | N.MetaProperty>();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(\n        this.startNodeAtNode<N.Identifier>(node),\n        \"new\",\n      );\n      this.next();\n      const metaProp = this.parseMetaProperty(\n        node as Undone<N.MetaProperty>,\n        meta,\n        \"target\",\n      );\n\n      if (\n        !this.scope.inNonArrowFunction &&\n        !this.scope.inClass &&\n        !this.options.allowNewTargetOutsideFunction\n      ) {\n        this.raise(Errors.UnexpectedNewTarget, { at: metaProp });\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node as Undone<N.NewExpression>);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(this: Parser, node: Undone<N.NewExpression>): N.NewExpression {\n    this.parseNewCallee(node);\n\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewCallee(this: Parser, node: Undone<N.NewExpression>): void {\n    node.callee = this.parseNoCallExpr();\n    if (node.callee.type === \"Import\") {\n      this.raise(Errors.ImportCallNotNewExpression, { at: node.callee });\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const { start, startLoc, end, value } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt<N.TemplateElement>(\n      createPositionWithColumnOffset(startLoc, 1),\n    );\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, {\n          // FIXME: Adding 1 is probably wrong.\n          at: createPositionWithColumnOffset(\n            this.state.firstInvalidTemplateEscapePos,\n            1,\n          ),\n        });\n      }\n    }\n\n    const isTail = this.match(tt.templateTail);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset),\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(\n      finishedNode,\n      createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset),\n    );\n    return finishedNode;\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(this: Parser, isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode<N.TemplateLiteral>();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(this: Parser): N.Expression {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike(\n    close: TokenType,\n    isPattern: true,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectPattern;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: false | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectExpression;\n  parseObjectLike(\n    close: TokenType,\n    isPattern: false,\n    isRecord?: true,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.RecordExpression;\n  parseObjectLike<T extends N.ObjectPattern | N.ObjectExpression>(\n    this: Parser,\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: boolean | null,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash: any = Object.create(null);\n    let first = true;\n    const node = this.startNode<\n      N.ObjectExpression | N.ObjectPattern | N.RecordExpression\n    >();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(\n            // @ts-expect-error todo(flow->ts) improve node types\n            node,\n          );\n          break;\n        }\n      }\n\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(Errors.InvalidRecordProperty, { at: prop });\n      }\n\n      // @ts-expect-error shorthand may not index prop\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      // @ts-expect-error Fixme: refine typings\n      node.properties.push(prop);\n    }\n\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    // @ts-expect-error type is well defined\n    return this.finishNode(node, type);\n  }\n\n  addTrailingCommaExtraToNode(node: N.Node): void {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(prop: Undone<N.ObjectProperty>): boolean {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    this: Parser,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMember | N.SpreadElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, {\n          at: this.state.startLoc,\n        });\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode<N.ObjectProperty>();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(tt.star);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop, refExpressionErrors);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, {\n            at: this.state.curPosition(),\n            kind: keyName,\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n\n    return this.parseObjPropValue(\n      prop,\n      startLoc,\n      isGenerator,\n      isAsync,\n      false /* isPattern */,\n      isAccessor,\n      refExpressionErrors,\n    );\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    if (params.length !== paramCount) {\n      this.raise(\n        method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity,\n        { at: method },\n      );\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(Errors.BadSetterRestParameter, { at: method });\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    this: Parser,\n    prop: Undone<N.ObjectMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): N.ObjectMethod | undefined | null {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      const finishedProp = this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    this: Parser,\n    prop: Undone<N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isPattern: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectProperty | undefined | null {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoverInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else if (this.match(tt.eq)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, {\n            at: shorthandAssignLoc,\n          });\n        }\n        prop.value = this.parseMaybeDefault(\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(\n    this: Parser,\n    prop: Undone<N.ObjectMethod | N.ObjectProperty>,\n    startLoc: Position | undefined | null,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.ObjectMethod | N.ObjectProperty {\n    const node =\n      this.parseObjectMethod(\n        prop as Undone<N.ObjectMethod>,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) ||\n      this.parseObjectProperty(\n        prop as Undone<N.ObjectProperty>,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      );\n\n    if (!node) this.unexpected();\n\n    return node;\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyName\n  // when refExpressionErrors presents, it will parse private name\n  // and record the position of the first private name\n  parsePropertyName(\n    this: Parser,\n    prop:\n      | Undone<N.ObjectOrClassMember | N.ClassMember>\n      | N.TsNamedTypeElementBase,\n    refExpressionErrors?: ExpressionErrors | null,\n  ): N.